import{r as h,R as wt}from"./index.ea0020fc.js";var Ut={exports:{}},at={};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ee=h,ne=Symbol.for("react.element"),se=Symbol.for("react.fragment"),re=Object.prototype.hasOwnProperty,oe=ee.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,ie={key:!0,ref:!0,__self:!0,__source:!0};function $t(t,e,n){var r,s={},o=null,c=null;n!==void 0&&(o=""+n),e.key!==void 0&&(o=""+e.key),e.ref!==void 0&&(c=e.ref);for(r in e)re.call(e,r)&&!ie.hasOwnProperty(r)&&(s[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps,e)s[r]===void 0&&(s[r]=e[r]);return{$$typeof:ne,type:t,key:o,ref:c,props:s,_owner:oe.current}}at.Fragment=se;at.jsx=$t;at.jsxs=$t;Ut.exports=at;var ze=Ut.exports;const Ke=()=>({home:"/",items:"/items",item(e){return`/item/${e}`}}),Ye=()=>({items(e){return`/api/items?q=${e}`},item(e){return`/api/items/${e}`}});var qt={exports:{}},kt={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var G=h;function ae(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var ce=typeof Object.is=="function"?Object.is:ae,ue=G.useState,fe=G.useEffect,le=G.useLayoutEffect,de=G.useDebugValue;function Ee(t,e){var n=e(),r=ue({inst:{value:n,getSnapshot:e}}),s=r[0].inst,o=r[1];return le(function(){s.value=n,s.getSnapshot=e,lt(s)&&o({inst:s})},[t,n,e]),fe(function(){return lt(s)&&o({inst:s}),t(function(){lt(s)&&o({inst:s})})},[t]),de(n),n}function lt(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ce(t,n)}catch{return!0}}function Re(t,e){return e()}var he=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Re:Ee;kt.useSyncExternalStore=G.useSyncExternalStore!==void 0?G.useSyncExternalStore:he;qt.exports=kt;var _e=qt.exports;const M=()=>{},O=M(),dt=Object,a=t=>t===O,W=t=>typeof t=="function",U=(t,e)=>({...t,...e}),pe=t=>W(t.then),ot=new WeakMap;let me=0;const tt=t=>{const e=typeof t,n=t&&t.constructor,r=n==Date;let s,o;if(dt(t)===t&&!r&&n!=RegExp){if(s=ot.get(t),s)return s;if(s=++me+"~",ot.set(t,s),n==Array){for(s="@",o=0;o<t.length;o++)s+=tt(t[o])+",";ot.set(t,s)}if(n==dt){s="#";const c=dt.keys(t).sort();for(;!a(o=c.pop());)a(t[o])||(s+=o+":"+tt(t[o])+",");ot.set(t,s)}}else s=r?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},P=new WeakMap,Et={},it={},gt="undefined",ct=typeof window!=gt,pt=typeof document!=gt,ve=()=>ct&&typeof window.requestAnimationFrame!=gt,jt=(t,e)=>{const n=P.get(t);return[()=>!a(e)&&t.get(e)||Et,r=>{if(!a(e)){const s=t.get(e);e in it||(it[e]=s),n[5](e,U(s,r),s||Et)}},n[6],()=>!a(e)&&e in it?it[e]:!a(e)&&t.get(e)||Et]};let mt=!0;const Se=()=>mt,[vt,St]=ct&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[M,M],Te=()=>{const t=pt&&document.visibilityState;return a(t)||t!=="hidden"},we=t=>(pt&&document.addEventListener("visibilitychange",t),vt("focus",t),()=>{pt&&document.removeEventListener("visibilitychange",t),St("focus",t)}),ge=t=>{const e=()=>{mt=!0,t()},n=()=>{mt=!1};return vt("online",e),vt("offline",n),()=>{St("online",e),St("offline",n)}},Oe={isOnline:Se,isVisible:Te},De={initFocus:we,initReconnect:ge},Ft=!wt.useId,et=!ct||"Deno"in window,Ce=t=>ve()?window.requestAnimationFrame(t):setTimeout(t,1),Rt=et?h.useEffect:h.useLayoutEffect,ht=typeof navigator<"u"&&navigator.connection,Pt=!et&&ht&&(["slow-2g","2g"].includes(ht.effectiveType)||ht.saveData),Ot=t=>{if(W(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?tt(t):"",[t,e]};let ye=0;const Tt=()=>++ye,Ht=0,Bt=1,Jt=2,be=3;var Z={__proto__:null,ERROR_REVALIDATE_EVENT:be,FOCUS_EVENT:Ht,MUTATE_EVENT:Jt,RECONNECT_EVENT:Bt};async function zt(...t){const[e,n,r,s]=t,o=U({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=o.populateCache;const E=o.rollbackOnError;let d=o.optimisticData;const A=o.revalidate!==!1,p=D=>typeof E=="function"?E(D):E!==!1,m=o.throwOnError;if(W(n)){const D=n,S=[],C=e.keys();for(const V of C)!/^\$(inf|sub)\$/.test(V)&&D(e.get(V)._k)&&S.push(V);return Promise.all(S.map(I))}return I(n);async function I(D){const[S]=Ot(D);if(!S)return;const[C,V]=jt(e,S),[i,j,X,$]=P.get(e),q=()=>{const w=i[S];return A&&(delete X[S],delete $[S],w&&w[0])?w[0](Jt).then(()=>C().data):C().data};if(t.length<3)return q();let T=r,y;const R=Tt();j[S]=[R,0];const H=!a(d),L=C(),B=L.data,nt=L._c,k=a(nt)?B:nt;if(H&&(d=W(d)?d(k,B):d,V({data:d,_c:k})),W(T))try{T=T(k)}catch(w){y=w}if(T&&pe(T))if(T=await T.catch(w=>{y=w}),R!==j[S][0]){if(y)throw y;return T}else y&&H&&p(y)&&(c=!0,V({data:k,_c:O}));if(c&&!y)if(W(c)){const w=c(T,k);V({data:w,error:O,_c:O})}else V({data:T,error:O,_c:O});if(j[S][1]=Tt(),Promise.resolve(q()).then(()=>{V({_c:O})}),y){if(m)throw y;return}return T}}const Wt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Ae=(t,e)=>{if(!P.has(t)){const n=U(De,e),r={},s=zt.bind(O,t);let o=M;const c={},E=(p,m)=>{const I=c[p]||[];return c[p]=I,I.push(m),()=>I.splice(I.indexOf(m),1)},d=(p,m,I)=>{t.set(p,m);const D=c[p];if(D)for(const S of D)S(m,I)},A=()=>{if(!P.has(t)&&(P.set(t,[r,{},{},{},s,d,E]),!et)){const p=n.initFocus(setTimeout.bind(O,Wt.bind(O,r,Ht))),m=n.initReconnect(setTimeout.bind(O,Wt.bind(O,r,Bt)));o=()=>{p&&p(),m&&m(),P.delete(t)}}};return A(),[t,s,A,o]}return[t,P.get(t)[4]]},Ie=(t,e,n,r,s)=>{const o=n.errorRetryCount,c=s.retryCount,E=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(o)&&c>o||setTimeout(r,E,s)},Ve=(t,e)=>tt(t)==tt(e),[Kt,Le]=Ae(new Map),Ne=U({onLoadingSlow:M,onSuccess:M,onError:M,onErrorRetry:Ie,onDiscarded:M,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Pt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Pt?5e3:3e3,compare:Ve,isPaused:()=>!1,cache:Kt,mutate:Le,fallback:{}},Oe),xe=(t,e)=>{const n=U(t,e);if(e){const{use:r,fallback:s}=t,{use:o,fallback:c}=e;r&&o&&(n.use=r.concat(o)),s&&c&&(n.fallback=U(s,c))}return n},Fe=h.createContext({}),Pe="$inf$",Yt=ct&&window.__SWR_DEVTOOLS_USE__,We=Yt?window.__SWR_DEVTOOLS_USE__:[],Me=()=>{Yt&&(window.__SWR_DEVTOOLS_REACT__=wt)},Ue=t=>W(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],$e=()=>U(Ne,h.useContext(Fe)),qe=t=>(e,n,r)=>t(e,n&&((...o)=>{const[c]=Ot(e),[,,,E]=P.get(Kt);if(c.startsWith(Pe))return n(...o);const d=E[c];return a(d)?n(...o):(delete E[c],d)}),r),ke=We.concat(qe),je=t=>function(...n){const r=$e(),[s,o,c]=Ue(n),E=xe(r,c);let d=t;const{use:A}=E,p=(A||[]).concat(ke);for(let m=p.length;m--;)d=p[m](d);return d(s,o||E.fetcher||null,E)},He=(t,e,n)=>{const r=e[t]||(e[t]=[]);return r.push(n),()=>{const s=r.indexOf(n);s>=0&&(r[s]=r[r.length-1],r.pop())}};Me();const Mt=wt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),_t={dedupe:!0},Be=(t,e,n)=>{const{cache:r,compare:s,suspense:o,fallbackData:c,revalidateOnMount:E,revalidateIfStale:d,refreshInterval:A,refreshWhenHidden:p,refreshWhenOffline:m,keepPreviousData:I}=n,[D,S,C,V]=P.get(r),[i,j]=Ot(t),X=h.useRef(!1),$=h.useRef(!1),q=h.useRef(i),T=h.useRef(e),y=h.useRef(n),R=()=>y.current,H=()=>R().isVisible()&&R().isOnline(),[L,B,nt,k]=jt(r,i),w=h.useRef({}).current,Gt=a(c)?n.fallback[i]:c,Dt=(u,f)=>{for(const v in w){const l=v;if(l==="data"){if(!s(u[l],f[l])&&(!a(u[l])||!s(rt,f[l])))return!1}else if(f[l]!==u[l])return!1}return!0},Ct=h.useMemo(()=>{const u=(()=>!i||!e?!1:a(E)?R().isPaused()||o?!1:a(d)?!0:d:E)(),f=g=>{const x=U(g);return delete x._k,u?{isValidating:!0,isLoading:!0,...x}:x},v=L(),l=k(),N=f(v),Y=v===l?N:f(l);let _=N;return[()=>{const g=f(L());return Dt(g,_)?(_.data=g.data,_.isLoading=g.isLoading,_.isValidating=g.isValidating,_.error=g.error,_):(_=g,g)},()=>Y]},[r,i]),J=_e.useSyncExternalStore(h.useCallback(u=>nt(i,(f,v)=>{Dt(v,f)||u()}),[r,i]),Ct[0],Ct[1]),yt=!X.current,Xt=D[i]&&D[i].length>0,z=J.data,K=a(z)?Gt:z,st=J.error,bt=h.useRef(K),rt=I?a(z)?bt.current:z:K,At=(()=>Xt&&!a(st)?!1:yt&&!a(E)?E:R().isPaused()?!1:o?a(K)?!1:d:a(K)||d)(),It=!!(i&&e&&yt&&At),Qt=a(J.isValidating)?It:J.isValidating,Zt=a(J.isLoading)?It:J.isLoading,Q=h.useCallback(async u=>{const f=T.current;if(!i||!f||$.current||R().isPaused())return!1;let v,l,N=!0;const Y=u||{},_=!C[i]||!Y.dedupe,g=()=>Ft?!$.current&&i===q.current&&X.current:i===q.current,x={isValidating:!1,isLoading:!1},Lt=()=>{B(x)},Nt=()=>{const b=C[i];b&&b[1]===l&&delete C[i]},xt={isValidating:!0};a(L().data)&&(xt.isLoading=!0);try{if(_&&(B(xt),n.loadingTimeout&&a(L().data)&&setTimeout(()=>{N&&g()&&R().onLoadingSlow(i,n)},n.loadingTimeout),C[i]=[f(j),Tt()]),[v,l]=C[i],v=await v,_&&setTimeout(Nt,n.dedupingInterval),!C[i]||C[i][1]!==l)return _&&g()&&R().onDiscarded(i),!1;x.error=O;const b=S[i];if(!a(b)&&(l<=b[0]||l<=b[1]||b[1]===0))return Lt(),_&&g()&&R().onDiscarded(i),!1;const F=L().data;x.data=s(F,v)?F:v,_&&g()&&R().onSuccess(v,i,n)}catch(b){Nt();const F=R(),{shouldRetryOnError:ut}=F;F.isPaused()||(x.error=b,_&&g()&&(F.onError(b,i,F),(ut===!0||W(ut)&&ut(b))&&H()&&F.onErrorRetry(b,i,F,te=>{const ft=D[i];ft&&ft[0]&&ft[0](Z.ERROR_REVALIDATE_EVENT,te)},{retryCount:(Y.retryCount||0)+1,dedupe:!0})))}return N=!1,Lt(),!0},[i,r]),Vt=h.useCallback((...u)=>zt(r,q.current,...u),[]);if(Rt(()=>{T.current=e,y.current=n,a(z)||(bt.current=z)}),Rt(()=>{if(!i)return;const u=Q.bind(O,_t);let f=0;const l=He(i,D,(N,Y={})=>{if(N==Z.FOCUS_EVENT){const _=Date.now();R().revalidateOnFocus&&_>f&&H()&&(f=_+R().focusThrottleInterval,u())}else if(N==Z.RECONNECT_EVENT)R().revalidateOnReconnect&&H()&&u();else{if(N==Z.MUTATE_EVENT)return Q();if(N==Z.ERROR_REVALIDATE_EVENT)return Q(Y)}});return $.current=!1,q.current=i,X.current=!0,B({_k:j}),At&&(a(K)||et?u():Ce(u)),()=>{$.current=!0,l()}},[i]),Rt(()=>{let u;function f(){const l=W(A)?A(L().data):A;l&&u!==-1&&(u=setTimeout(v,l))}function v(){!L().error&&(p||R().isVisible())&&(m||R().isOnline())?Q(_t).then(f):f()}return f(),()=>{u&&(clearTimeout(u),u=-1)}},[A,p,m,i]),h.useDebugValue(rt),o&&a(K)&&i){if(!Ft&&et)throw new Error("Fallback data is required when using suspense in SSR.");T.current=e,y.current=n,$.current=!1;const u=V[i];if(!a(u)){const f=Vt(u);Mt(f)}if(a(st)){const f=Q(_t);a(rt)||(f.status="fulfilled",f.value=!0),Mt(f)}else throw st}return{mutate:Vt,get data(){return w.data=!0,rt},get error(){return w.error=!0,st},get isValidating(){return w.isValidating=!0,Qt},get isLoading(){return w.isLoading=!0,Zt}}},Ge=je(Be);export{Ye as a,Ke as g,ze as j,Ge as u};
